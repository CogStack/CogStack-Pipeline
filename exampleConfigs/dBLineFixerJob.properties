# EXAMPLE CONFIG FOR dBLineFixerJob 
elasticsearch.cluster.name = elasticsearch
elasticsearch.cluster.host =  127.0.0.1
elasticsearch.cluster.port = 9300
elasticsearch.shield.enabled = false
elasticsearch.shield.user = <user>:<password>
elasticsearch.shield.ssl.keystore.path = /home/rich/elk/ssh-keystores/tempnode/tempnode.jks
elasticsearch.shield.ssl.keystore.password = <password>
elasticsearch.shield.ssl.truststore.path = /home/rich/elk/ssh-keystores/tempnode/tempnode.jks
elasticsearch.shield.ssl.truststore.password = <password>
elasticsearch.shield.transport.ssl = true
elasticsearch.index.name = test_index2
elasticsearch.type = test_type
elasticsearch.response.timeout = 1000000
#do not index these fields if detected
elasticsearch.excludeFromIndexing = binaryContent

datePatternForES = yyyy-MM-dd'T'HH:mm:ss.SSS
#for DBLineFixer
# primary key of document
lf.documentKeyName = primaryKeyFieldValue
lf.lineKeyName = line_id
lf.lineContents = line_text
#source table of lines
lf.srcTableName = tblDocLines

# fieldname for lineFixer output
dbLineFixerFieldName = lineFixer

##JMS config
jmsIP = tcp://172.17.0.3:61616?jms.prefetchPolicy.all=1
jmsUsername = admin
jmsPassword = your_password

elasticsearch.cluster.name = elasticsearch
elasticsearch.cluster.host =  127.0.0.1
elasticsearch.cluster.port = 9300
elasticsearch.shield.enabled = false
elasticsearch.shield.user = <user>:<password>
elasticsearch.shield.ssl.keystore.path = /home/rich/elk/ssh-keystores/tempnode/tempnode.jks
elasticsearch.shield.ssl.keystore.password = <password>
elasticsearch.shield.ssl.truststore.path = /home/rich/elk/ssh-keystores/tempnode/tempnode.jks
elasticsearch.shield.ssl.truststore.password = <password>
elasticsearch.shield.transport.ssl = true
elasticsearch.index.name = test_index2
elasticsearch.type = test_type
elasticsearch.response.timeout = 1000000
#do not index these fields if detected
elasticsearch.excludeFromIndexing = binaryContent

datePatternForES = yyyy-MM-dd'T'HH:mm:ss.SSS
# commit interval in step
chunkSize = 50
skipLimit = 0


#Asynchonous TaskExecutor Thread pool size
concurrencyLimit = 4

# DB field names for metadata
srcTableName = srctablename
srcColumnFieldName = srcColumnFieldName
primaryKeyFieldName = primaryKeyFieldName
primaryKeyFieldValue = primaryKeyFieldValue
timeStamp = updateTime


#Scheduling config
#if false, run a single job
useScheduling = true
## scheduling (Cron style syntax)
scheduler.rate = */5 * * * * *

#if useTimeStampBasedScheduling ia true, process this number of milliseconds from last successful job/first timestamp/start date,
#depending on configuration and status of the JobRepository
processingPeriod = 864000000000

#if included, start from this date on first job. Also specify a start timestamp in ms, for restarting at a given point. See joda docs.
#firstJobStartDate = 2016-05-10 10:23:31.2
#datePatternForSQL = yyyy-MM-dd HH:mm:ss.S

## Total timeout in ms for complete job (set high for long running jobs!)
jobTimeout = 10000
#select profiles to activate various ItemProcessor/ItemWriter Beans
spring.profiles.active=basic,master,slave,jdbc,elasticsearch,primaryKeyPartition
## POSTGRES TARGET DB CONFIGURATIONS
target.JdbcPath      = jdbc:postgresql://172.17.0.2:5432/minicogs
target.Driver        = org.postgresql.Driver
target.username      = postgres
target.password      = mysecretpassword
target.idleTimeout   = 30000
target.maxLifetime   = 60000

## SOURCE TARGET DB CONFIGURATIONS
source.JdbcPath      = jdbc:postgresql://172.17.0.2:5432/minicogs
source.Driver        = org.postgresql.Driver
source.username      = postgres
source.password      = mysecretpassword
source.idleTimeout   = 30000
source.maxLifetime   = 60000

## Job Repo DB CONFIGURATIONS
jobRepository.JdbcPath      = jdbc:postgresql://172.17.0.2:5432/minicogs
jobRepository.Driver        = org.postgresql.Driver
jobRepository.username      = postgres
jobRepository.password      = mysecretpassword
jobRepository.idleTimeout   = 30000
jobRepository.maxLifetime   = 60000


datePatternForScheduling = yyyy-MM-dd HH:mm:ss.S
dbmsToJavaSqlTimestampType = TIMESTAMP




## Job and step Name
jobName =   dBLineFixerJob

# line fixer IO queries
target.Sql           = INSERT INTO tblOutputDocs (srcColumnFieldName, srcTableName, primaryKeyFieldName, primaryKeyFieldValue, updateTime,  LINE_TEXT_CONCAT) VALUES (:srcColumnFieldName, :srcTableName, :primaryKeyFieldName, CAST( :primaryKeyFieldValue AS integer) , :timeStamp,  :outputData)
#currently not used
target.validationQuery = SELECT * FROM tblOutputDocs

## paging item reader line fixer
source.selectClause = SELECT distinct srcColumnFieldName, srcTableName, primaryKeyFieldName,  primaryKeyFieldValue , updateTime
source.sortKey = primaryKeyFieldValue
##paging item reader
source.pageSize = 2
source.fromClause = FROM tblInputDocs 

#for partitioning
#if the step target table has a different alias to the partition table
columnToProcess = primaryKeyFieldValue
#this is the table containing the primary keys and timestamps
tableToPartition = tblInputDocs
pkColumnNameToPartition = primaryKeyFieldValue
timeStampColumnNameToPersistInJobRepository = updateTime

##Configure partitionHandler
gridSize = 4
partitionHandlerTimeout = 100000
requestQueueName = lineFixerReqChannel
replyQueueName = lineFixerReplyQueue
##needed for some dbms
#partitionerPreFieldsSQL =
#partitionerPostOrderByClause = limit 10


#for build/testing
spring.profiles.active=dBLineFixer,master,slave,jdbc,elasticsearch
